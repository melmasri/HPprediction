#' A function to sample the estimated parameters and construct the posterior probability matrix
#'
#' @param model model generated by \code{\link{network_est}}
#' @param size the number of posterior samples to use for each parameter (default is 1000)
#' @param weights indicator of weights to use (optional)
#' 
#' 
#' @description
#' 
#' This function samples the affinity and phylogeny scaling parameters from the posterior and constructs the posterior probability matrix 'P'. Dimension names are assigned from matrix `Z`.
#' 
#' @return 
#' Returns the posterior probability matrix 'P'
#'
#' @examples
#' \dontrun{}
#'  
#' @export
#'
sample_parameter <-
    function(model, size = 1000){
        weights  = NULL
        param = model$param
        Z = model$Z
        num.dist= model$num.distances
        distances  = model$distances
        MODEL = model$model.type
        ny = nrow(Z)
        
        sample_mcmc<-function(mcmc_sample, nObs, size = 1000){
            if(is.matrix(mcmc_sample)
               )
                mcmc_sample[, sample.int(nObs, size, replace = TRUE)] else
                                                                          mcmc_sample[sample.int(nObs, size, replace = TRUE)]
        }
        
        if(grepl('(dist|full)', MODEL)){
            if(num.dist==1){
                dist.original = distances_metadata(distances)
                Eta = sample_mcmc(param$eta, length(param$eta), size)
            }else{
                dist.original = distances_metadata(distances)
                Eta = sample_mcmc(param$eta, length(param$eta[1,]), size)
                dist.weights = sample_mcmc(param$dist.weights, length(param$dist.weights[1,]), size)
            }
        } else Eta = 1
        
        if(grepl('dist', MODEL)) {
            Y = W = 1
        }else{
            Y = sample_mcmc(param$y, ncol(param$y), size)
            W = sample_mcmc(param$w, ncol(param$w), size)
            if(is.null(param$distance)){
                constant_distance = 1
            }else
                constant_distance = param$distance
        }
        zeroZ = which(Z>0)
        P <- 0
        for(s in 1:size){
            ## aux = sapply(1:size, function(s){
            ## setting affinity to 1 in distance model
            if(grepl('(aff|full)', MODEL)){
                YW = outer(Y[,s], W[,s]) * constant_distance
            } else YW = 1
            
            ## Full or distance model
            ## Creating distance
            if(grepl('(full|dist)', MODEL)){
                if(num.dist ==1){
                    ea = Eta[s]
                    ##ea = sign(Eta[s])*min(abs(Eta[s]), 600)
                                       
                    distance = 1/dist.original$kernel_func(dist = dist.original$dist,
                                                           tmax=dist.original$t.max,
                                                           eta=ea,
                                                           param=dist.original$param)
                    diag(distance)<-0
                    distance = distance %*% Z
                    distance[distance==0] <- if(grepl('dist', MODEL)) Inf else 1
                }else{
                    aa = lapply(1:num.dist, function(i){
                        ea =Eta[i,s]
                        a = dist.original[[i]]$kernel_func(
                                                   dist = dist.original[[i]]$dist,
                                                   tmax = dist.original[[i]]$t.max,
                                                   eta=ea,
                                                   param=dist.original[[i]]$param)
                        a
                    })
                    dist = 1/matrix(matrix(unlist(aa), ny*ny, num.dist) %*% dist.weights[, s], ny, ny)
                    diag(dist)<-0
                    distance = dist %*% Z
                    distance[distance==0] <- if(grepl('dist', MODEL)) Inf else 1
                }
            } else distance = 1
            ## models
            ## P = 1-exp(-outer(Y, W))                 # affinity model
            ## P = 1-exp(-distance)                    # distance model
            ## P = 1-exp(-YW*distance)                 # full model
            ## All in one probability matrix
            
            if(!is.null(weights)){
                a =  1-  exp(-YW*distance)
                Pg = a * weights[s] /(1-a + weights[s] * a)
                Pg[zeroZ] <- a[zeroZ]
                P = P + Pg
            }else{
                P = P + 1-  exp(-YW*distance)
            }
        }

        ## })
        P = matrix(P/size, nrow = nrow(Z), ncol = ncol(Z))
        colnames(P)<-colnames(Z)
        rownames(P)<-rownames(Z)
        P
    }

